import boto3
import time
import json
import logging
import paramiko
from pathlib import Path
from typing import Dict, Optional, List, Tuple
from botocore.exceptions import ClientError
from .config import AWSConfigManager, EC2Config
from .storage import StrangerThingsS3Manager

class EC2TrainingManager:
    """Manage EC2 instances for training and Gradio app deployment"""
    
    def __init__(self, config_manager: AWSConfigManager):
        self.config = config_manager
        self.ec2_client = boto3.client('ec2', region_name=self.config.ec2_config.region)
        self.ec2_resource = boto3.resource('ec2', region_name=self.config.ec2_config.region)
        self.s3_manager = StrangerThingsS3Manager(
            bucket_name=self.config.s3_config.bucket_name
        )
        
        # Track running instances
        self.training_instances = {}
        self.gradio_instances = {}
        
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)
    
    def create_security_group(self, name: str = "stranger-things-sg") -> str:
        """Create security group for EC2 instances"""
        try:
            # Check if security group already exists
            existing_sgs = self.ec2_client.describe_security_groups(
                Filters=[{'Name': 'group-name', 'Values': [name]}]
            )
            
            if existing_sgs['SecurityGroups']:
                sg_id = existing_sgs['SecurityGroups'][0]['GroupId']
                self.logger.info(f"Using existing security group: {sg_id}")
                return sg_id
            
            # Create new security group
            response = self.ec2_client.create_security_group(
                GroupName=name,
                Description="Security group for Stranger Things NLP project"
            )
            
            sg_id = response['GroupId']
            
            # Add rules for SSH and Gradio
            self.ec2_client.authorize_security_group_ingress(
                GroupId=sg_id,
                IpPermissions=[\n                    {\n                        'IpProtocol': 'tcp',\n                        'FromPort': 22,\n                        'ToPort': 22,\n                        'IpRanges': [{'CidrIp': '0.0.0.0/0'}]\n                    },\n                    {\n                        'IpProtocol': 'tcp',\n                        'FromPort': self.config.gradio_config.port,\n                        'ToPort': self.config.gradio_config.port,\n                        'IpRanges': [{'CidrIp': '0.0.0.0/0'}]\n                    },\n                    {\n                        'IpProtocol': 'tcp',\n                        'FromPort': 80,\n                        'ToPort': 80,\n                        'IpRanges': [{'CidrIp': '0.0.0.0/0'}]\n                    },\n                    {\n                        'IpProtocol': 'tcp',\n                        'FromPort': 443,\n                        'ToPort': 443,\n                        'IpRanges': [{'CidrIp': '0.0.0.0/0'}]\n                    }\n                ]\n            )\n            \n            self.logger.info(f\"Created security group: {sg_id}\")\n            return sg_id\n            \n        except ClientError as e:\n            self.logger.error(f\"Error creating security group: {e}\")\n            raise\n    \n    def launch_training_instance(self, \n                                model_type: str = \"llama\",\n                                training_job_name: str = None) -> Dict:\n        \"\"\"Launch EC2 instance for model training\"\"\"\n        \n        if training_job_name is None:\n            training_job_name = f\"training-{model_type}-{int(time.time())}\"\n        \n        # Ensure security group exists\n        sg_id = self.create_security_group()\n        \n        # Prepare user data script\n        user_data = self.config.get_ec2_user_data_script()\n        \n        try:\n            # Launch instance\n            if self.config.ec2_config.use_spot_instances:\n                response = self.ec2_client.request_spot_instances(\n                    SpotPrice=str(self.config.ec2_config.max_spot_price),\n                    InstanceCount=1,\n                    Type='one-time',\n                    LaunchSpecification={\n                        'ImageId': self.config.ec2_config.ami_id,\n                        'InstanceType': self.config.ec2_config.instance_type,\n                        'KeyName': self.config.ec2_config.key_pair_name,\n                        'SecurityGroupIds': [sg_id],\n                        'UserData': user_data,\n                        'BlockDeviceMappings': [\n                            {\n                                'DeviceName': '/dev/sda1',\n                                'Ebs': {\n                                    'VolumeSize': self.config.ec2_config.volume_size,\n                                    'VolumeType': self.config.ec2_config.volume_type,\n                                    'DeleteOnTermination': True\n                                }\n                            }\n                        ],\n                        'IamInstanceProfile': {\n                            'Name': 'EC2-S3-Access'  # Assume this role exists\n                        }\n                    }\n                )\n                \n                spot_request_id = response['SpotInstanceRequests'][0]['SpotInstanceRequestId']\n                self.logger.info(f\"Launched spot instance request: {spot_request_id}\")\n                \n                # Wait for spot instance to be fulfilled\n                instance_id = self._wait_for_spot_instance(spot_request_id)\n                \n            else:\n                response = self.ec2_client.run_instances(\n                    ImageId=self.config.ec2_config.ami_id,\n                    MinCount=1,\n                    MaxCount=1,\n                    InstanceType=self.config.ec2_config.instance_type,\n                    KeyName=self.config.ec2_config.key_pair_name,\n                    SecurityGroupIds=[sg_id],\n                    UserData=user_data,\n                    BlockDeviceMappings=[\n                        {\n                            'DeviceName': '/dev/sda1',\n                            'Ebs': {\n                                'VolumeSize': self.config.ec2_config.volume_size,\n                                'VolumeType': self.config.ec2_config.volume_type,\n                                'DeleteOnTermination': True\n                            }\n                        }\n                    ],\n                    IamInstanceProfile={\n                        'Name': 'EC2-S3-Access'  # Assume this role exists\n                    },\n                    TagSpecifications=[\n                        {\n                            'ResourceType': 'instance',\n                            'Tags': [\n                                {'Key': 'Name', 'Value': f'stranger-things-training-{model_type}'},\n                                {'Key': 'Project', 'Value': 'stranger-things-nlp'},\n                                {'Key': 'Purpose', 'Value': 'training'}\n                            ]\n                        }\n                    ]\n                )\n                \n                instance_id = response['Instances'][0]['InstanceId']\n                self.logger.info(f\"Launched on-demand instance: {instance_id}\")\n            \n            # Wait for instance to be running\n            self.logger.info(\"Waiting for instance to be running...\")\n            waiter = self.ec2_client.get_waiter('instance_running')\n            waiter.wait(InstanceIds=[instance_id])\n            \n            # Get instance details\n            instance_info = self._get_instance_info(instance_id)\n            \n            # Store training job info\n            self.training_instances[training_job_name] = {\n                'instance_id': instance_id,\n                'model_type': model_type,\n                'public_ip': instance_info['public_ip'],\n                'private_ip': instance_info['private_ip'],\n                'launch_time': time.time(),\n                'status': 'initializing'\n            }\n            \n            self.logger.info(f\"Training instance ready: {instance_info['public_ip']}\")\n            return self.training_instances[training_job_name]\n            \n        except ClientError as e:\n            self.logger.error(f\"Error launching training instance: {e}\")\n            raise\n    \n    def launch_gradio_instance(self) -> Dict:\n        \"\"\"Launch EC2 instance for Gradio app hosting\"\"\"\n        \n        # Use smaller instance for Gradio hosting\n        gradio_config = self.config.ec2_config\n        gradio_config.instance_type = \"t3.medium\"  # Smaller instance for hosting\n        \n        sg_id = self.create_security_group()\n        \n        # Modified user data for Gradio hosting\n        user_data = self._get_gradio_user_data_script()\n        \n        try:\n            response = self.ec2_client.run_instances(\n                ImageId=gradio_config.ami_id,\n                MinCount=1,\n                MaxCount=1,\n                InstanceType=gradio_config.instance_type,\n                KeyName=gradio_config.key_pair_name,\n                SecurityGroupIds=[sg_id],\n                UserData=user_data,\n                IamInstanceProfile={\n                    'Name': 'EC2-S3-Access'\n                },\n                TagSpecifications=[\n                    {\n                        'ResourceType': 'instance',\n                        'Tags': [\n                            {'Key': 'Name', 'Value': 'stranger-things-gradio'},\n                            {'Key': 'Project', 'Value': 'stranger-things-nlp'},\n                            {'Key': 'Purpose', 'Value': 'gradio-hosting'}\n                        ]\n                    }\n                ]\n            )\n            \n            instance_id = response['Instances'][0]['InstanceId']\n            \n            # Wait for instance to be running\n            waiter = self.ec2_client.get_waiter('instance_running')\n            waiter.wait(InstanceIds=[instance_id])\n            \n            instance_info = self._get_instance_info(instance_id)\n            \n            self.gradio_instances['main'] = {\n                'instance_id': instance_id,\n                'public_ip': instance_info['public_ip'],\n                'private_ip': instance_info['private_ip'],\n                'launch_time': time.time(),\n                'status': 'initializing',\n                'gradio_url': f\"http://{instance_info['public_ip']}:{self.config.gradio_config.port}\"\n            }\n            \n            self.logger.info(f\"Gradio instance ready: {instance_info['public_ip']}\")\n            return self.gradio_instances['main']\n            \n        except ClientError as e:\n            self.logger.error(f\"Error launching Gradio instance: {e}\")\n            raise\n    \n    def deploy_code_to_instance(self, instance_info: Dict, \n                               local_project_path: str = \".\") -> bool:\n        \"\"\"Deploy code to EC2 instance via SCP\"\"\"\n        try:\n            # Create SSH client\n            ssh_client = paramiko.SSHClient()\n            ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n            \n            # Connect to instance\n            key_path = Path(f\"~/.ssh/{self.config.ec2_config.key_pair_name}.pem\").expanduser()\n            ssh_client.connect(\n                hostname=instance_info['public_ip'],\n                username='ubuntu',\n                key_filename=str(key_path)\n            )\n            \n            # Upload project files\n            sftp = ssh_client.open_sftp()\n            \n            local_path = Path(local_project_path)\n            remote_base = \"/home/ubuntu/stranger-things-nlp\"\n            \n            # Upload essential files\n            essential_files = [\n                'requirements.txt',\n                'gradio_app.py',\n                'aws/',\n                'character_chatbot/',\n                'text_classification/',\n                'theme_classifier/',\n                'character_network/',\n                'utils/'\n            ]\n            \n            for item in essential_files:\n                local_item = local_path / item\n                if local_item.exists():\n                    if local_item.is_file():\n                        remote_path = f\"{remote_base}/{item}\"\n                        sftp.put(str(local_item), remote_path)\n                        self.logger.info(f\"Uploaded {item}\")\n                    else:\n                        # Upload directory recursively\n                        self._upload_directory_recursive(sftp, str(local_item), f\"{remote_base}/{item}\")\n            \n            sftp.close()\n            \n            # Install requirements\n            commands = [\n                \"cd /home/ubuntu/stranger-things-nlp\",\n                \"source venv/bin/activate\",\n                \"pip install -r requirements.txt\"\n            ]\n            \n            for cmd in commands:\n                stdin, stdout, stderr = ssh_client.exec_command(cmd)\n                stdout.read()  # Wait for completion\n            \n            ssh_client.close()\n            self.logger.info(\"Code deployment completed\")\n            return True\n            \n        except Exception as e:\n            self.logger.error(f\"Error deploying code: {e}\")\n            return False\n    \n    def start_training(self, training_job_name: str, model_type: str = \"llama\") -> bool:\n        \"\"\"Start training on EC2 instance\"\"\"\n        if training_job_name not in self.training_instances:\n            self.logger.error(f\"Training job not found: {training_job_name}\")\n            return False\n        \n        instance_info = self.training_instances[training_job_name]\n        \n        try:\n            # Create SSH client\n            ssh_client = paramiko.SSHClient()\n            ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n            \n            key_path = Path(f\"~/.ssh/{self.config.ec2_config.key_pair_name}.pem\").expanduser()\n            ssh_client.connect(\n                hostname=instance_info['public_ip'],\n                username='ubuntu',\n                key_filename=str(key_path)\n            )\n            \n            # Set environment variables\n            env_vars = self.config.get_training_environment_vars()\n            env_setup = \" && \".join([f\"export {k}={v}\" for k, v in env_vars.items()])\n            \n            # Start training command\n            training_script = f\"\"\"\n            cd /home/ubuntu/stranger-things-nlp\n            source venv/bin/activate\n            {env_setup}\n            \n            python -c \"\n            from character_chatbot.character_chatbot import CharacterChatbot\n            import os\n            \n            # Download training data from S3\n            # This would be implemented in the updated chatbot class\n            chatbot = CharacterChatbot(\n                model_path='christopherxzyx/StrangerThings_{model_type.title()}-3-4B_ec2',\n                data_path='/tmp/training_data/',\n                huggingface_token=os.getenv('HUGGINGFACE_TOKEN')\n            )\n            print('Training completed successfully')\n            \"\n            \"\"\"\n            \n            # Execute training in background\n            command = f\"nohup bash -c '{training_script}' > training.log 2>&1 &\"\n            ssh_client.exec_command(command)\n            \n            # Update status\n            self.training_instances[training_job_name]['status'] = 'training'\n            \n            ssh_client.close()\n            self.logger.info(f\"Started training for job: {training_job_name}\")\n            return True\n            \n        except Exception as e:\n            self.logger.error(f\"Error starting training: {e}\")\n            return False\n    \n    def start_gradio_app(self) -> bool:\n        \"\"\"Start Gradio app on EC2 instance\"\"\"\n        if 'main' not in self.gradio_instances:\n            self.logger.error(\"No Gradio instance found\")\n            return False\n        \n        instance_info = self.gradio_instances['main']\n        \n        try:\n            ssh_client = paramiko.SSHClient()\n            ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n            \n            key_path = Path(f\"~/.ssh/{self.config.ec2_config.key_pair_name}.pem\").expanduser()\n            ssh_client.connect(\n                hostname=instance_info['public_ip'],\n                username='ubuntu',\n                key_filename=str(key_path)\n            )\n            \n            # Start Gradio app\n            gradio_command = f\"\"\"\n            cd /home/ubuntu/stranger-things-nlp\n            source venv/bin/activate\n            \n            export GRADIO_SERVER_NAME=0.0.0.0\n            export GRADIO_SERVER_PORT={self.config.gradio_config.port}\n            \n            nohup python gradio_app.py > gradio.log 2>&1 &\n            \"\"\"\n            \n            ssh_client.exec_command(gradio_command)\n            \n            # Update status\n            self.gradio_instances['main']['status'] = 'running'\n            \n            ssh_client.close()\n            self.logger.info(f\"Started Gradio app: {instance_info['gradio_url']}\")\n            return True\n            \n        except Exception as e:\n            self.logger.error(f\"Error starting Gradio app: {e}\")\n            return False\n    \n    def terminate_instance(self, instance_id: str) -> bool:\n        \"\"\"Terminate EC2 instance\"\"\"\n        try:\n            self.ec2_client.terminate_instances(InstanceIds=[instance_id])\n            self.logger.info(f\"Terminated instance: {instance_id}\")\n            return True\n        except ClientError as e:\n            self.logger.error(f\"Error terminating instance: {e}\")\n            return False\n    \n    def get_training_status(self, training_job_name: str) -> Dict:\n        \"\"\"Get status of training job\"\"\"\n        if training_job_name not in self.training_instances:\n            return {'status': 'not_found'}\n        \n        return self.training_instances[training_job_name]\n    \n    def list_instances(self) -> Dict:\n        \"\"\"List all project instances\"\"\"\n        return {\n            'training': self.training_instances,\n            'gradio': self.gradio_instances\n        }\n    \n    def _wait_for_spot_instance(self, spot_request_id: str, timeout: int = 300) -> str:\n        \"\"\"Wait for spot instance request to be fulfilled\"\"\"\n        start_time = time.time()\n        \n        while time.time() - start_time < timeout:\n            response = self.ec2_client.describe_spot_instance_requests(\n                SpotInstanceRequestIds=[spot_request_id]\n            )\n            \n            request = response['SpotInstanceRequests'][0]\n            state = request['State']\n            \n            if state == 'active':\n                return request['InstanceId']\n            elif state == 'failed':\n                raise Exception(f\"Spot request failed: {request.get('Fault', 'Unknown error')}\")\n            \n            time.sleep(10)\n        \n        raise Exception(\"Timeout waiting for spot instance\")\n    \n    def _get_instance_info(self, instance_id: str) -> Dict:\n        \"\"\"Get instance information\"\"\"\n        response = self.ec2_client.describe_instances(InstanceIds=[instance_id])\n        instance = response['Reservations'][0]['Instances'][0]\n        \n        return {\n            'instance_id': instance_id,\n            'public_ip': instance.get('PublicIpAddress', ''),\n            'private_ip': instance.get('PrivateIpAddress', ''),\n            'state': instance['State']['Name']\n        }\n    \n    def _get_gradio_user_data_script(self) -> str:\n        \"\"\"Get user data script for Gradio instance\"\"\"\n        base_script = self.config.get_ec2_user_data_script()\n        \n        # Add Gradio-specific setup\n        gradio_setup = \"\"\"\n# Additional setup for Gradio hosting\nsudo -u ubuntu bash << 'EOF'\ncd /home/ubuntu/stranger-things-nlp\n\n# Install nginx for reverse proxy (optional)\n# sudo apt-get install -y nginx\n\necho \"Gradio instance setup completed\" >> gradio_setup.log\nEOF\n\"\"\"\n        \n        return base_script + \"\\n\" + gradio_setup\n    \n    def _upload_directory_recursive(self, sftp, local_dir: str, remote_dir: str):\n        \"\"\"Upload directory recursively via SFTP\"\"\"\n        local_path = Path(local_dir)\n        \n        # Create remote directory\n        try:\n            sftp.mkdir(remote_dir)\n        except:\n            pass  # Directory might already exist\n        \n        for item in local_path.iterdir():\n            local_item_path = str(item)\n            remote_item_path = f\"{remote_dir}/{item.name}\"\n            \n            if item.is_file():\n                sftp.put(local_item_path, remote_item_path)\n            elif item.is_dir() and not item.name.startswith('.'):\n                self._upload_directory_recursive(sftp, local_item_path, remote_item_path)